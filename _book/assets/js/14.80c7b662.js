(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{356:function(t,_,s){t.exports=s.p+"assets/img/buffer_optimize_1.092a66fe.png"},398:function(t,_,s){"use strict";s.r(_);var v=s(7),o=Object(v.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[t._v("缓冲区是 MQTT 在通信过程中用于存放数据的内存片段，正确的容量配置策略可以达到内存开销与通信性能的最佳平衡点。")]),t._v(" "),_("p",[t._v("为每个TCP连接分配的读缓冲区大小，是在服务启动前便以参数配置的形式确定下来，运行期不可更改。")]),t._v(" "),_("p",[t._v("所以，"),_("strong",[t._v("过小的配置值将使得缓冲区无法容纳一个完整的 MQTT 消息包，导致解码异常")]),t._v("；"),_("strong",[t._v("而过大的容量配置，又会带来内存浪费的问题")]),t._v("。")]),t._v(" "),_("p",[_("img",{attrs:{src:s(356),alt:""}})]),t._v(" "),_("p",[t._v("为了最大化提升资源的利用率，我们引入了临时缓冲区的策略。\n当消息大小超过默认的读缓冲区容量时，通过申请一片足够大小的临时空间，完成消息解码后再将其释放掉。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("思考")]),t._v(" "),_("p",[t._v("这个时候我们只需思考一个问题：如何设置读缓冲区的大小？")])]),t._v(" "),_("p",[t._v("缓冲区的大小设置需要考虑机器内存资源，客户端连接数，以及客户端产生的并发量等因素。\n归根结底我们的目标是在有限的内存开销下，尽可能保障 IO 效率。")]),t._v(" "),_("ol",[_("li",[t._v("如果连接数不多，这意味着缓冲区的硬性开销不会太高，此时可以使其尽可能容纳所有消息的大小。")]),t._v(" "),_("li",[t._v("当存在海量设备连接，但消息并发量又不高，可以将缓冲区容量设置在能够覆盖 [20%~40%] 的消息大小范围内，以此可以节省不必要的内存浪费。")]),t._v(" "),_("li",[t._v("当存在海量设备连接，且消息并发量也比较高，需要尽量使缓冲区能够容纳 80%~90% 的消息大小，否则频繁申请临时缓冲区会增加GC负担。")])]),t._v(" "),_("blockquote",[_("p",[t._v("上面的数值百分比仅作为参考，实际场景下要结合调整后的效果而定。")])])])}),[],!1,null,null,null);_.default=o.exports}}]);